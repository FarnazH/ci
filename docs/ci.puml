@startuml

namespace ci {

    class State {
        __ private members __
            - const double eigenvalue
            - const Eigen::VectorXd eigenvector
        == constructors ==
            **State**()
            **State**(double eigenvalue, const Eigen::VectorXd& eigenvector)
        __ public methods __
            + double **get_eigenvalue**() const
            + Eigen::VectorXd **get_eigenvector**() const

            + bool **isDegenerate**(const ci::State& other, double tolerance = 1.0e-06) const
            + bool **hasLowerEnergy**(const ci::State& other, double tolerance = 1.0e-06) const
    }


    abstract class CI {
        __ protected members __
            # size_t nelec
            # size_t K
            # size_t nbf
            # doci::State lowestEigenState
            # doci::CI_basis* basis
            # doci::Hamiltonian* hamiltonian
        __ protected methods __
            # virtual void **calculateCI**(size_t start, size_t end)=0
            # virtual void **construct**()=0
        == constructors ==
            **CI**()
            **CI**(CI_basis *ciBasis)
        __ public methods __
            + Hamiltonian* **getHamiltonian**() const
    }


    class DOCI {
        __ private members __
            - size_t npairs
            - bmqc::AddressingScheme ad_mat
        __ private methods __
            - void **calculateCI**(size_t start, size_t end) override
            - void **construct**() override
        == constructors ==
            **DOCI**(CI_basis *ciBasis)
    }




    abstract class BaseHamiltonianSolver {
        __ protected members __
            # const size_t dimension

            # bool is_solved = false
            # std::vector<doci::State> ground_states
        __ protected methods __
            # void **addToGroundStates**(const ci::State& state)
        __ public methods __
            + std::vector<ci::State> **get_ground_states**() const

            + virtual void **solve**() = 0
            + virtual void **addElement**(double value, size_t index1, size_t index2) = 0;

            + {static} Hamiltonian* **make_hamiltonian**(size_t nbf);
    }


    class DenseHamiltonianSolver {
        __ private members __
            - Eigen::MatrixXd hamiltonian
        == constructors ==
            **DenseHamiltonian**(size_t nbf)
        __ public methods __
            + const Eigen::MatrixXd& **getHamiltonian**() const

            + void **solve**() override
            + void **add**(double value, size_t index1, size_t index2) override
    }
}


namespace bmqc {
    class AddressingScheme {
        == constructors ==
            **AddressingScheme**(size_t K, size_t N)
        __ public methods __
            + const bmqc::Matrixi **get_vertex_weights**() const
    }


    class SpinString<T> {
        == constructors ==
            **SpinString**<T>(size_t address, const bmqc::AddressingScheme& addressing_scheme)
        __ public methods __
            + size_t **address**(const bmqc::AddressingScheme& addressing_scheme) const
            + bool **annihilate**(size_t p)
            + bool **create**(size_t p)
    }
}


namespace libwint {
    class SOBasis {
        == constructors ==
            **SOBasis**(const libwint::AOBasis& ao_basis, Eigen::MatrixXd& C)
        __ public methods __
            + inline const libwint::AOBasis& **get_ao_basis**() const
            + inline Eigen::MatrixXd& **get_h_SO**() const
            + inline Eigen::Tensor<double, 4>& **get_g_SO**() const
            + inline const size_t **get_K**() const

            + void **transform**(Eigen::MatrixXd& T)
            + void **transformJacobi**(size_t p, size_t q, double angle)
    }
}


ci.BaseHamiltonianSolver o--> ci.State

ci.DenseHamiltonianSolver --|> ci.BaseHamiltonianSolver

ci.CI *--> ci.State
ci.CI o--> libwint.SOBasis
ci.CI *--> ci.BaseHamiltonianSolver

ci.DOCI --|> ci.CI
ci.DOCI *--> bmqc.AddressingScheme
ci.DOCI ..> bmqc.SpinString


@enduml